{"version":3,"sources":["ChunkedStream.js"],"names":["define","skylark","langx","DecodeStream","Class","declare","-parent-","Stream","-interfaces-","-protected-","-fields-","numChunks","numChunksLoaded","-methods-","-public-","-attributes-","getMissingChunks","chunks","chunk","n","this","loadedChunks","push","getBaseStreams","allChunksLoaded","_","onReceiveData","begin","end","byteLength","assert","chunkSize","length","bytes","set","Uint8Array","beginChunk","Math","floor","endChunk","onReceiveInitialData","data","initialDataLength","i","ensureRange","MissingDataException","nextEmptyChunk","hasChunk","getByte","pos","getBytes","strEnd","subarray","peekBytes","getByteRange","skip","reset","start","moveStart","makeSubStream","dict","ChunkedStreamSubstream","prototype","Object","create","missingChunks","subStream","-constructor-","initialize","overload","str","charCodeAt","overrided"],"mappings":"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","file":"../ChunkedStream.js","sourcesContent":["define([\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"./DecodeStream\"\r\n], function(skylark, langx,DecodeStream) {\r\n\r\n\r\n    var ChunkedStream = Class.declare({\r\n        \"-parent-\": Stream,\r\n\r\n        \"-interfaces-\": [],\r\n\r\n        \"-protected-\": {\r\n            \"-fields-\": {\r\n                \"numChunks\": 0,\r\n                \"numChunksLoaded\": 0\r\n            },\r\n\r\n            \"-methods-\": {\r\n\r\n            }\r\n        },\r\n\r\n        \"-public-\": {\r\n            \"-attributes-\": {\r\n\r\n\r\n            },\r\n            \"-methods-\": {\r\n                \"numChunks\": function() {\r\n\r\n                },\r\n\r\n\r\n                getMissingChunks: function ChunkedStream_getMissingChunks() {\r\n                    var chunks = [];\r\n                    for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {\r\n                        if (!(chunk in this.loadedChunks)) {\r\n                            chunks.push(chunk);\r\n                        }\r\n                    }\r\n                    return chunks;\r\n                },\r\n\r\n                getBaseStreams: function ChunkedStream_getBaseStreams() {\r\n                    return [this];\r\n                },\r\n\r\n                allChunksLoaded: function ChunkedStream_allChunksLoaded() {\r\n                    var _ = this._;\r\n                    return _.numChunksLoaded === _.numChunks;\r\n                },\r\n\r\n                onReceiveData: function(begin, chunk) {\r\n                    var end = begin + chunk.byteLength;\r\n\r\n                    assert(begin % this.chunkSize === 0, 'Bad begin offset: ' + begin);\r\n                    // Using this.length is inaccurate here since this.start can be moved\r\n                    // See ChunkedStream.moveStart()\r\n                    var length = this.bytes.length;\r\n                    assert(end % this.chunkSize === 0 || end === length,\r\n                        'Bad end offset: ' + end);\r\n\r\n                    this.bytes.set(new Uint8Array(chunk), begin);\r\n                    var chunkSize = this.chunkSize;\r\n                    var beginChunk = Math.floor(begin / chunkSize);\r\n                    var endChunk = Math.floor((end - 1) / chunkSize) + 1;\r\n\r\n                    for (var chunk = beginChunk; chunk < endChunk; ++chunk) {\r\n                        if (!(chunk in this.loadedChunks)) {\r\n                            this.loadedChunks[chunk] = true;\r\n                            ++this.numChunksLoaded;\r\n                        }\r\n                    }\r\n                },\r\n\r\n                onReceiveInitialData: function(data) {\r\n                    this.bytes.set(data);\r\n                    this.initialDataLength = data.length;\r\n                    var endChunk = this.end === data.length ?\r\n                        this.numChunks : Math.floor(data.length / this.chunkSize);\r\n                    for (var i = 0; i < endChunk; i++) {\r\n                        this.loadedChunks[i] = true;\r\n                        ++this.numChunksLoaded;\r\n                    }\r\n                },\r\n\r\n                ensureRange: function ChunkedStream_ensureRange(begin, end) {\r\n                    if (begin >= end) {\r\n                        return;\r\n                    }\r\n\r\n                    if (end <= this.initialDataLength) {\r\n                        return;\r\n                    }\r\n\r\n                    var chunkSize = this.chunkSize;\r\n                    var beginChunk = Math.floor(begin / chunkSize);\r\n                    var endChunk = Math.floor((end - 1) / chunkSize) + 1;\r\n                    for (var chunk = beginChunk; chunk < endChunk; ++chunk) {\r\n                        if (!(chunk in this.loadedChunks)) {\r\n                            throw new MissingDataException(begin, end);\r\n                        }\r\n                    }\r\n                },\r\n\r\n                nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {\r\n                    for (var chunk = beginChunk, n = this.numChunks; chunk < n; ++chunk) {\r\n                        if (!(chunk in this.loadedChunks)) {\r\n                            return chunk;\r\n                        }\r\n                    }\r\n                    // Wrap around to beginning\r\n                    for (var chunk = 0; chunk < beginChunk; ++chunk) {\r\n                        if (!(chunk in this.loadedChunks)) {\r\n                            return chunk;\r\n                        }\r\n                    }\r\n                    return null;\r\n                },\r\n\r\n                hasChunk: function ChunkedStream_hasChunk(chunk) {\r\n                    return chunk in this._.loadedChunks;\r\n                },\r\n\r\n                getByte: function ChunkedStream_getByte() {\r\n                    var pos = this.pos;\r\n                    if (pos >= this.end) {\r\n                        return -1;\r\n                    }\r\n                    this.ensureRange(pos, pos + 1);\r\n                    return this.bytes[this.pos++];\r\n                },\r\n\r\n                // returns subarray of original buffer\r\n                // should only be read\r\n                getBytes: function ChunkedStream_getBytes(length) {\r\n                    var bytes = this.bytes;\r\n                    var pos = this.pos;\r\n                    var strEnd = this.end;\r\n\r\n                    if (!length) {\r\n                        this.ensureRange(pos, strEnd);\r\n                        return bytes.subarray(pos, strEnd);\r\n                    }\r\n\r\n                    var end = pos + length;\r\n                    if (end > strEnd)\r\n                        end = strEnd;\r\n                    this.ensureRange(pos, end);\r\n\r\n                    this.pos = end;\r\n                    return bytes.subarray(pos, end);\r\n                },\r\n\r\n                peekBytes: function ChunkedStream_peekBytes(length) {\r\n                    var bytes = this.getBytes(length);\r\n                    this.pos -= bytes.length;\r\n                    return bytes;\r\n                },\r\n\r\n                getByteRange: function ChunkedStream_getBytes(begin, end) {\r\n                    this.ensureRange(begin, end);\r\n                    return this.bytes.subarray(begin, end);\r\n                },\r\n\r\n                skip: function ChunkedStream_skip(n) {\r\n                    if (!n)\r\n                        n = 1;\r\n                    this.pos += n;\r\n                },\r\n\r\n                reset: function ChunkedStream_reset() {\r\n                    this.pos = this.start;\r\n                },\r\n\r\n                moveStart: function ChunkedStream_moveStart() {\r\n                    this.start = this.pos;\r\n                },\r\n\r\n                makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {\r\n                    function ChunkedStreamSubstream() {}\r\n                    ChunkedStreamSubstream.prototype = Object.create(this);\r\n                    ChunkedStreamSubstream.prototype.getMissingChunks = function() {\r\n                        var chunkSize = this.chunkSize;\r\n                        var beginChunk = Math.floor(this.start / chunkSize);\r\n                        var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;\r\n                        var missingChunks = [];\r\n                        for (var chunk = beginChunk; chunk < endChunk; ++chunk) {\r\n                            if (!(chunk in this.loadedChunks)) {\r\n                                missingChunks.push(chunk);\r\n                            }\r\n                        }\r\n                        return missingChunks;\r\n                    };\r\n                    var subStream = new ChunkedStreamSubstream();\r\n                    subStream.pos = subStream.start = start;\r\n                    subStream.end = start + length || this.end;\r\n                    subStream.dict = dict;\r\n                    return subStream;\r\n                }\r\n\r\n            }\r\n        },\r\n        \"-constructor-\": {\r\n            \"initialize\": [\r\n\r\n                function() {\r\n                    this.overload(\"\");\r\n                },\r\n\r\n                function( /*String*/ str) {\r\n                    var length = str.length;\r\n                    var bytes = new Uint8Array(length);\r\n                    for (var n = 0; n < length; ++n)\r\n                        bytes[n] = str.charCodeAt(n);\r\n                    this.overrided(bytes);\r\n                }\r\n            ]\r\n\r\n        }\r\n\r\n    });\r\n\r\n    return ChunkedStream;\r\n\r\n});\r\n"]}