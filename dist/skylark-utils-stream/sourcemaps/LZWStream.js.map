{"version":3,"sources":["LZWStream.js"],"names":["define","skylark","langx","streams","DecodeStream","LZWStream","inherit","klassName","init","str","earlyChange","this","dict","cachedData","bitsCached","maxLzwDictionarySize","lzwState","codeLength","nextCode","dictionaryValues","Uint8Array","dictionaryLengths","Uint16Array","dictionaryPrevCodes","currentSequence","currentSequenceLength","i","overrided","readBits","n","c","getByte","eof","lastCode","readBlock","j","q","blockSize","estimatedDecodedSize","decodedSizeDelta","prevCode","decodedLength","currentBufferLength","bufferLength","buffer","ensureBuffer","code","hasPrev","Math","min","log"],"mappings":"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","file":"../LZWStream.js","sourcesContent":["define([\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"./streams\",\r\n    \"./DecodeStream\"\r\n], function(skylark, langx, streams, DecodeStream) {\r\n\r\n    var LZWStream = DecodeStream.inherit({\r\n        klassName : \"LZWStream\",\r\n\r\n        init : function(str, earlyChange) {\r\n            this.str = str;\r\n            this.dict = str.dict;\r\n            this.cachedData = 0;\r\n            this.bitsCached = 0;\r\n\r\n            var maxLzwDictionarySize = 4096;\r\n            var lzwState = {\r\n                earlyChange: earlyChange,\r\n                codeLength: 9,\r\n                nextCode: 258,\r\n                dictionaryValues: new Uint8Array(maxLzwDictionarySize),\r\n                dictionaryLengths: new Uint16Array(maxLzwDictionarySize),\r\n                dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),\r\n                currentSequence: new Uint8Array(maxLzwDictionarySize),\r\n                currentSequenceLength: 0\r\n            };\r\n            for (var i = 0; i < 256; ++i) {\r\n                lzwState.dictionaryValues[i] = i;\r\n                lzwState.dictionaryLengths[i] = 1;\r\n            }\r\n            this.lzwState = lzwState;\r\n            this.overrided();          \r\n        },\r\n\r\n        readBits : function(n) {\r\n            var bitsCached = this.bitsCached;\r\n            var cachedData = this.cachedData;\r\n            while (bitsCached < n) {\r\n                var c = this.str.getByte();\r\n                if (c == null) {\r\n                    this.eof = true;\r\n                    return null;\r\n                }\r\n                cachedData = (cachedData << 8) | c;\r\n                bitsCached += 8;\r\n            }\r\n            this.bitsCached = (bitsCached -= n);\r\n            this.cachedData = cachedData;\r\n            this.lastCode = null;\r\n            return (cachedData >>> bitsCached) & ((1 << n) - 1);\r\n        },\r\n\r\n        readBlock : function() {\r\n            var blockSize = 512;\r\n            var estimatedDecodedSize = blockSize * 2,\r\n                decodedSizeDelta = blockSize;\r\n            var i, j, q;\r\n\r\n            var lzwState = this.lzwState;\r\n            if (!lzwState)\r\n                return; // eof was found\r\n\r\n            var earlyChange = lzwState.earlyChange;\r\n            var nextCode = lzwState.nextCode;\r\n            var dictionaryValues = lzwState.dictionaryValues;\r\n            var dictionaryLengths = lzwState.dictionaryLengths;\r\n            var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;\r\n            var codeLength = lzwState.codeLength;\r\n            var prevCode = lzwState.prevCode;\r\n            var currentSequence = lzwState.currentSequence;\r\n            var currentSequenceLength = lzwState.currentSequenceLength;\r\n\r\n            var decodedLength = 0;\r\n            var currentBufferLength = this.bufferLength;\r\n            var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);\r\n\r\n            for (i = 0; i < blockSize; i++) {\r\n                var code = this.readBits(codeLength);\r\n                var hasPrev = currentSequenceLength > 0;\r\n                if (code < 256) {\r\n                    currentSequence[0] = code;\r\n                    currentSequenceLength = 1;\r\n                } else if (code >= 258) {\r\n                    if (code < nextCode) {\r\n                        currentSequenceLength = dictionaryLengths[code];\r\n                        for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {\r\n                            currentSequence[j] = dictionaryValues[q];\r\n                            q = dictionaryPrevCodes[q];\r\n                        }\r\n                    } else {\r\n                        currentSequence[currentSequenceLength++] = currentSequence[0];\r\n                    }\r\n                } else if (code == 256) {\r\n                    codeLength = 9;\r\n                    nextCode = 258;\r\n                    currentSequenceLength = 0;\r\n                    continue;\r\n                } else {\r\n                    this.eof = true;\r\n                    delete this.lzwState;\r\n                    break;\r\n                }\r\n\r\n                if (hasPrev) {\r\n                    dictionaryPrevCodes[nextCode] = prevCode;\r\n                    dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;\r\n                    dictionaryValues[nextCode] = currentSequence[0];\r\n                    nextCode++;\r\n                    codeLength = (nextCode + earlyChange) & (nextCode + earlyChange - 1) ?\r\n                        codeLength : Math.min(Math.log(nextCode + earlyChange) /\r\n                            0.6931471805599453 + 1, 12) | 0;\r\n                }\r\n                prevCode = code;\r\n\r\n                decodedLength += currentSequenceLength;\r\n                if (estimatedDecodedSize < decodedLength) {\r\n                    do {\r\n                        estimatedDecodedSize += decodedSizeDelta;\r\n                    } while (estimatedDecodedSize < decodedLength);\r\n                    buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);\r\n                }\r\n                for (j = 0; j < currentSequenceLength; j++)\r\n                    buffer[currentBufferLength++] = currentSequence[j];\r\n            }\r\n            lzwState.nextCode = nextCode;\r\n            lzwState.codeLength = codeLength;\r\n            lzwState.prevCode = prevCode;\r\n            lzwState.currentSequenceLength = currentSequenceLength;\r\n\r\n            this.bufferLength = currentBufferLength;\r\n        }\r\n    });\r\n\r\n    return streams.LZWStream = LZWStream;\r\n});\r\n"]}