{"version":3,"sources":["PredictorStream.js"],"names":["define","skylark","langx","streams","DecodeStream","PredictorStream","inherit","klassName","init","stream","params","predictor","this","get","error","readBlock","readBlockTiff","readBlockPng","dict","colors","bits","columns","pixBytes","rowBytes","overrided","bufferLength","buffer","ensureBuffer","rawBytes","getBytes","inbuf","outbuf","inbits","outbits","pos","i","c","compArray","Uint8Array","bitMask","j","k","kk","getByte","prevRow","subarray","length","up","upLeft","left","p","pa","pb","pc"],"mappings":"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","file":"../PredictorStream.js","sourcesContent":["\r\ndefine([\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"./streams\",\r\n    \"./DecodeStream\"\r\n], function(skylark, langx, streams, DecodeStream) {\r\n\r\n    var PredictorStream = DecodeStream.inherit({\r\n        klassName : \"PredictorStream\",\r\n\r\n        init : function(stream, params) {\r\n            var predictor = this.predictor = params.get('Predictor') || 1;\r\n\r\n            if (predictor <= 1)\r\n                return stream; // no prediction\r\n            if (predictor !== 2 && (predictor < 10 || predictor > 15))\r\n                error('Unsupported predictor: ' + predictor);\r\n\r\n            if (predictor === 2)\r\n                this.readBlock = this.readBlockTiff;\r\n            else\r\n                this.readBlock = this.readBlockPng;\r\n\r\n            this.stream = stream;\r\n            this.dict = stream.dict;\r\n\r\n            var colors = this.colors = params.get('Colors') || 1;\r\n            var bits = this.bits = params.get('BitsPerComponent') || 8;\r\n            var columns = this.columns = params.get('Columns') || 1;\r\n\r\n            this.pixBytes = (colors * bits + 7) >> 3;\r\n            this.rowBytes = (columns * colors * bits + 7) >> 3;\r\n            this.overrided();          \r\n        },\r\n\r\n        readBlockTiff : function () {\r\n                var rowBytes = this.rowBytes;\r\n\r\n                var bufferLength = this.bufferLength;\r\n                var buffer = this.ensureBuffer(bufferLength + rowBytes);\r\n\r\n                var bits = this.bits;\r\n                var colors = this.colors;\r\n\r\n                var rawBytes = this.stream.getBytes(rowBytes);\r\n\r\n                var inbuf = 0,\r\n                    outbuf = 0;\r\n                var inbits = 0,\r\n                    outbits = 0;\r\n                var pos = bufferLength;\r\n\r\n                if (bits === 1) {\r\n                    for (var i = 0; i < rowBytes; ++i) {\r\n                        var c = rawBytes[i];\r\n                        inbuf = (inbuf << 8) | c;\r\n                        // bitwise addition is exclusive or\r\n                        // first shift inbuf and then add\r\n                        buffer[pos++] = (c ^ (inbuf >> colors)) & 0xFF;\r\n                        // truncate inbuf (assumes colors < 16)\r\n                        inbuf &= 0xFFFF;\r\n                    }\r\n                } else if (bits === 8) {\r\n                    for (var i = 0; i < colors; ++i)\r\n                        buffer[pos++] = rawBytes[i];\r\n                    for (; i < rowBytes; ++i) {\r\n                        buffer[pos] = buffer[pos - colors] + rawBytes[i];\r\n                        pos++;\r\n                    }\r\n                } else {\r\n                    var compArray = new Uint8Array(colors + 1);\r\n                    var bitMask = (1 << bits) - 1;\r\n                    var j = 0,\r\n                        k = bufferLength;\r\n                    var columns = this.columns;\r\n                    for (var i = 0; i < columns; ++i) {\r\n                        for (var kk = 0; kk < colors; ++kk) {\r\n                            if (inbits < bits) {\r\n                                inbuf = (inbuf << 8) | (rawBytes[j++] & 0xFF);\r\n                                inbits += 8;\r\n                            }\r\n                            compArray[kk] = (compArray[kk] +\r\n                                (inbuf >> (inbits - bits))) & bitMask;\r\n                            inbits -= bits;\r\n                            outbuf = (outbuf << bits) | compArray[kk];\r\n                            outbits += bits;\r\n                            if (outbits >= 8) {\r\n                                buffer[k++] = (outbuf >> (outbits - 8)) & 0xFF;\r\n                                outbits -= 8;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (outbits > 0) {\r\n                        buffer[k++] = (outbuf << (8 - outbits)) +\r\n                            (inbuf & ((1 << (8 - outbits)) - 1));\r\n                    }\r\n                }\r\n                this.bufferLength += rowBytes;\r\n        },\r\n\r\n        readBlockPng : function() {\r\n\r\n                var rowBytes = this.rowBytes;\r\n                var pixBytes = this.pixBytes;\r\n\r\n                var predictor = this.stream.getByte();\r\n                var rawBytes = this.stream.getBytes(rowBytes);\r\n\r\n                var bufferLength = this.bufferLength;\r\n                var buffer = this.ensureBuffer(bufferLength + rowBytes);\r\n\r\n                var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);\r\n                if (prevRow.length == 0)\r\n                    prevRow = new Uint8Array(rowBytes);\r\n\r\n                var j = bufferLength;\r\n                switch (predictor) {\r\n                    case 0:\r\n                        for (var i = 0; i < rowBytes; ++i)\r\n                            buffer[j++] = rawBytes[i];\r\n                        break;\r\n                    case 1:\r\n                        for (var i = 0; i < pixBytes; ++i)\r\n                            buffer[j++] = rawBytes[i];\r\n                        for (; i < rowBytes; ++i) {\r\n                            buffer[j] = (buffer[j - pixBytes] + rawBytes[i]) & 0xFF;\r\n                            j++;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        for (var i = 0; i < rowBytes; ++i)\r\n                            buffer[j++] = (prevRow[i] + rawBytes[i]) & 0xFF;\r\n                        break;\r\n                    case 3:\r\n                        for (var i = 0; i < pixBytes; ++i)\r\n                            buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];\r\n                        for (; i < rowBytes; ++i) {\r\n                            buffer[j] = (((prevRow[i] + buffer[j - pixBytes]) >> 1) +\r\n                                rawBytes[i]) & 0xFF;\r\n                            j++;\r\n                        }\r\n                        break;\r\n                    case 4:\r\n                        // we need to save the up left pixels values. the simplest way\r\n                        // is to create a new buffer\r\n                        for (var i = 0; i < pixBytes; ++i) {\r\n                            var up = prevRow[i];\r\n                            var c = rawBytes[i];\r\n                            buffer[j++] = up + c;\r\n                        }\r\n                        for (; i < rowBytes; ++i) {\r\n                            var up = prevRow[i];\r\n                            var upLeft = prevRow[i - pixBytes];\r\n                            var left = buffer[j - pixBytes];\r\n                            var p = left + up - upLeft;\r\n\r\n                            var pa = p - left;\r\n                            if (pa < 0)\r\n                                pa = -pa;\r\n                            var pb = p - up;\r\n                            if (pb < 0)\r\n                                pb = -pb;\r\n                            var pc = p - upLeft;\r\n                            if (pc < 0)\r\n                                pc = -pc;\r\n\r\n                            var c = rawBytes[i];\r\n                            if (pa <= pb && pa <= pc)\r\n                                buffer[j++] = left + c;\r\n                            else if (pb <= pc)\r\n                                buffer[j++] = up + c;\r\n                            else\r\n                                buffer[j++] = upLeft + c;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        error('Unsupported predictor: ' + predictor);\r\n                }\r\n                this.bufferLength += rowBytes;\r\n        }\r\n    });\r\n\r\n    return streams.PredictorStream = PredictorStream;\r\n});\r\n"]}